## 列表

demo1：边迭代边操作列表
```
squares = [1, 2, 3]
for i in range(len(squares)):
    if squares[i] > 1:：
        del squares[i]
```
没有意外的索引越界了。
于是，有童鞋想到了赋值给变量，然后保留。
demo2：可变对象赋值给变量
```
squares = [1, 2, 3]
li1 = squares
for i in range(len(li1)):
    if li1[i] > 1:
        del li1[i]
```
依然索引越界。我们来看下为什么，
```
print(id(squares),id(li1))
(4492291848, 4492291848)
```
可以看出=赋值,squares和li1都指向一个对象。接下来
demo3:浅拷贝
```
squares = [1,2,3,4]
li1 = squares[:]
for i in range(len(li1)):
    if li1[i] > 1:
        del squares[i]
```


1.切片
```
>>> squares = [1,2,3,4]
>>> b=squares[:]
```




列表推导不会再有变量泄漏的问题
Python 2.x 中，在列表推导中 for 关键词之后的赋值操作可能会影
响列表推导上下文中的同名变量。
```
Python 2.7.6 (default, Mar 22 2014, 22:59:38)
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> x = 'my precious'
>>> dummy = [x for x in 'ABC']
>>> x
'C'
```
列表推导、生成器表达式，以及同它们很相似的集合（set）推导
和字典（dict）推导，在 Python 3 中都有了自己的局部作用域，就
像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的
上下文里的同名变量还可以被正常引用，局部变量并不会影响到它
们。
这是Python 3 代码：
```
>>> x = 'ABC'
>>> dummy = [ord(x) for x in x]
>>> x 
'ABC'
>>> dummy 
[65, 66, 67]
>>>
```